
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{CV\_project}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{Artificial Intelligence
Nanodegree}\label{artificial-intelligence-nanodegree}

\subsection{Computer Vision Capstone}\label{computer-vision-capstone}

\subsection{Project: Facial Keypoint
Detection}\label{project-facial-keypoint-detection}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

Welcome to the final Computer Vision project in the Artificial
Intelligence Nanodegree program!

In this project, you'll combine your knowledge of computer vision
techniques and deep learning to build and end-to-end facial keypoint
recognition system! Facial keypoints include points around the eyes,
nose, and mouth on any face and are used in many applications, from
facial tracking to emotion recognition.

There are three main parts to this project:

\textbf{Part 1} : Investigating OpenCV, pre-processing, and face
detection

\textbf{Part 2} : Training a Convolutional Neural Network (CNN) to
detect facial keypoints

\textbf{Part 3} : Putting parts 1 and 2 together to identify facial
keypoints on any image!

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

**Here's what you need to know to complete the project:*

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  In this notebook, some template code has already been provided for
  you, and you will need to implement additional functionality to
  successfully complete this project. You will not need to modify the
  included code beyond what is requested.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \tightlist
  \item
    Sections that begin with \textbf{'(IMPLEMENTATION)'} in the header
    indicate that the following block of code will require additional
    functionality which you must provide. Instructions will be provided
    for each section, and the specifics of the implementation are marked
    in the code block with a 'TODO' statement. Please be sure to read
    the instructions carefully!
  \end{enumerate}
\item
  In addition to implementing code, there will be questions that you
  must answer which relate to the project and your implementation.

  \begin{enumerate}
  \def\labelenumii{\alph{enumii}.}
  \item
    Each section where you will answer a question is preceded by a
    \textbf{'Question X'} header.
  \item
    Carefully read each question and provide thorough answers in the
    following text boxes that begin with \textbf{'Answer:'}.
  \end{enumerate}
\end{enumerate}

\begin{quote}
\textbf{Note:} Code and Markdown cells can be executed using the
\textbf{Shift + Enter} keyboard shortcut. Markdown cells can be edited
by double-clicking the cell to enter edit mode.
\end{quote}

The rubric contains \textbf{optional} suggestions for enhancing the
project beyond the minimum requirements. If you decide to pursue the
"(Optional)" sections, you should include the code in this IPython
notebook.

Your project submission will be evaluated based on your answers to
\emph{each} of the questions and the code implementations you provide.

    \subsubsection{Steps to Complete the
Project}\label{steps-to-complete-the-project}

Each part of the notebook is further broken down into separate steps.
Feel free to use the links below to navigate the notebook.

In this project you will get to explore a few of the many computer
vision algorithms built into the OpenCV library. This expansive computer
vision library is now
\href{https://en.wikipedia.org/wiki/OpenCV\#History}{almost 20 years
old} and still growing!

The project itself is broken down into three large parts, then even
further into separate steps. Make sure to read through each step, and
complete any sections that begin with \textbf{'(IMPLEMENTATION)'} in the
header; these implementation sections may contain multiple TODOs that
will be marked in code. For convenience, we provide links to each of
these steps below.

\textbf{Part 1} : Investigating OpenCV, pre-processing, and face
detection

\begin{itemize}
\tightlist
\item
  Section \ref{step0}: Detect Faces Using a Haar Cascade Classifier
\item
  Section \ref{step1}: Add Eye Detection
\item
  Section \ref{step2}: De-noise an Image for Better Face Detection
\item
  Section \ref{step3}: Blur an Image and Perform Edge Detection
\item
  Section \ref{step4}: Automatically Hide the Identity of an Individual
\end{itemize}

\textbf{Part 2} : Training a Convolutional Neural Network (CNN) to
detect facial keypoints

\begin{itemize}
\tightlist
\item
  Section \ref{step5}: Create a CNN to Recognize Facial Keypoints
\item
  Section \ref{step6}: Compile and Train the Model
\item
  Section \ref{step7}: Visualize the Loss and Answer Questions
\end{itemize}

\textbf{Part 3} : Putting parts 1 and 2 together to identify facial
keypoints on any image!

\begin{itemize}
\tightlist
\item
  Section \ref{step7}: Build a Robust Facial Keypoints Detector
  (Complete the CV Pipeline)
\end{itemize}

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

 \#\# Step 0: Detect Faces Using a Haar Cascade Classifier

Have you ever wondered how Facebook automatically tags images with your
friends' faces? Or how high-end cameras automatically find and focus on
a certain person's face? Applications like these depend heavily on the
machine learning task known as \emph{face detection} - which is the task
of automatically finding faces in images containing people.

At its root face detection is a classification problem - that is a
problem of distinguishing between distinct classes of things. With face
detection these distinct classes are 1) images of human faces and 2)
everything else.

We use OpenCV's implementation of
\href{http://docs.opencv.org/trunk/d7/d8b/tutorial_py_face_detection.html}{Haar
feature-based cascade classifiers} to detect human faces in images.
OpenCV provides many pre-trained face detectors, stored as XML files on
\href{https://github.com/opencv/opencv/tree/master/data/haarcascades}{github}.
We have downloaded one of these detectors and stored it in the
\texttt{detector\_architectures} directory.

    \subsubsection{Import Resources}\label{import-resources}

In the next python cell, we load in the required libraries for this
section of the project.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{c+c1}{\PYZsh{} Import required libraries for this section}
        
        \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
        
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k+kn}{as} \PY{n+nn}{np}
        \PY{k+kn}{import} \PY{n+nn}{matplotlib.pyplot} \PY{k+kn}{as} \PY{n+nn}{plt}
        \PY{k+kn}{import} \PY{n+nn}{math}
        \PY{k+kn}{import} \PY{n+nn}{cv2}                     \PY{c+c1}{\PYZsh{} OpenCV library for computer vision}
        \PY{k+kn}{from} \PY{n+nn}{PIL} \PY{k+kn}{import} \PY{n}{Image}
        \PY{k+kn}{import} \PY{n+nn}{time} 
\end{Verbatim}


    Next, we load in and display a test image for performing face detection.

\emph{Note}: by default OpenCV assumes the ordering of our image's color
channels are Blue, then Green, then Red. This is slightly out of order
with most image types we'll use in these experiments, whose color
channels are ordered Red, then Green, then Blue. In order to switch the
Blue and Red channels of our test image around we will use OpenCV's
\texttt{cvtColor} function, which you can read more about by
\href{http://docs.opencv.org/3.2.0/df/d9d/tutorial_py_colorspaces.html}{checking
out some of its documentation located here}. This is a general utility
function that can do other transformations too like converting a color
image to grayscale, and transforming a standard color image to HSV color
space.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
        \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/test\PYZus{}image\PYZus{}1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
        \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Plot our image using subplots to specify a size and title}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}2}]:} <matplotlib.image.AxesImage at 0x1172599d0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_6_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    There are a lot of people - and faces - in this picture. 13 faces to be
exact! In the next code cell, we demonstrate how to use a Haar Cascade
classifier to detect all the faces in this test image.

This face detector uses information about patterns of intensity in an
image to reliably detect faces under varying light conditions. So, to
use this face detector, we'll first convert the image from color to
grayscale.

Then, we load in the fully trained architecture of the face detector
-\/- found in the file \emph{haarcascade\_frontalface\_default.xml} -
and use it on our image to find faces!

To learn more about the parameters of the detector see
\href{https://stackoverflow.com/questions/20801015/recommended-values-for-opencv-detectmultiscale-parameters}{this
post}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
        \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
        \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Detect the faces in image}
        \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
        \PY{k}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
        \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
        \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
            
        
        \PY{c+c1}{\PYZsh{} Display the image with the detections}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face Detections}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
('Number of faces detected:', 13)

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}4}]:} <matplotlib.image.AxesImage at 0x11aeaddd0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_8_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    In the above code, \texttt{faces} is a numpy array of detected faces,
where each row corresponds to a detected face. Each detected face is a
1D array with four entries that specifies the bounding box of the
detected face. The first two entries in the array (extracted in the
above code as \texttt{x} and \texttt{y}) specify the horizontal and
vertical positions of the top left corner of the bounding box. The last
two entries in the array (extracted here as \texttt{w} and \texttt{h})
specify the width and height of the box.

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 1: Add Eye Detections}\label{step-1-add-eye-detections}

There are other pre-trained detectors available that use a Haar Cascade
Classifier - including full human body detectors, license plate
detectors, and more.
\href{https://github.com/opencv/opencv/tree/master/data/haarcascades}{A
full list of the pre-trained architectures can be found here}.

    To test your eye detector, we'll first read in a new test image with
just a single face.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
        \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/james.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
        \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Plot the RGB image}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}5}]:} <matplotlib.image.AxesImage at 0x11c6dd190>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_12_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Notice that even though the image is a black and white image, we have
read it in as a color image and so it will still need to be converted to
grayscale in order to perform the most accurate face detection.

So, the next steps will be to convert this image to grayscale, then load
OpenCV's face detector and run it with parameters that detect this face
accurately.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
        \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
        \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Detect the faces in image}
        \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
        \PY{k}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
        \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
        \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
            
        
        \PY{c+c1}{\PYZsh{} Display the image with the detections}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face Detection}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
('Number of faces detected:', 1)

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}6}]:} <matplotlib.image.AxesImage at 0x11ae6ee50>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_14_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{(IMPLEMENTATION) Add an eye detector to the current face
detection
setup.}\label{implementation-add-an-eye-detector-to-the-current-face-detection-setup.}

A Haar-cascade eye detector can be included in the same way that the
face detector was and, in this first task, it will be your job to do
just this.

    To set up an eye detector, use the stored parameters of the eye cascade
detector, called \texttt{haarcascade\_eye.xml}, located in the
\texttt{detector\_architectures} subdirectory. In the next code cell,
create your eye detector and store its detections.

\textbf{A few notes before you get started}:

First, make sure to give your loaded eye detector the variable name

\texttt{eye\_cascade}

and give the list of eye regions you detect the variable name

\texttt{eyes}

Second, since we've already run the face detector over this image, you
should only search for eyes \emph{within the rectangular face regions
detected in \texttt{faces}}. This will minimize false detections.

Lastly, once you've run your eye detector over the facial detection
region, you should display the RGB image with both the face detection
boxes (in red) and your eye detections (in green) to verify that
everything works as expected.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{} Make a copy of the original image to plot rectangle detections}
         \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}   
         
         \PY{c+c1}{\PYZsh{} Loop over the detections and draw their corresponding face detection boxes}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}  
             
         \PY{c+c1}{\PYZsh{} Do not change the code above this comment!}
         
             
         \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Add eye detection, using haarcascade\PYZus{}eye.xml, to the current face detector algorithm}
         \PY{n}{eye\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}eye.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{n}{roi\PYZus{}gray} \PY{o}{=} \PY{n}{gray}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
             \PY{n}{roi\PYZus{}color} \PY{o}{=} \PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
             
             \PY{n}{eyes} \PY{o}{=} \PY{n}{eye\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{roi\PYZus{}gray}\PY{p}{)}
         \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Loop over the eye detections and draw their corresponding boxes in green on image\PYZus{}with\PYZus{}detections}
             \PY{k}{for} \PY{p}{(}\PY{n}{x1}\PY{p}{,}\PY{n}{y1}\PY{p}{,}\PY{n}{w1}\PY{p}{,}\PY{n}{h1}\PY{p}{)} \PY{o+ow}{in} \PY{n}{eyes}\PY{p}{:}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{roi\PYZus{}color}\PY{p}{,}\PY{p}{(}\PY{n}{x1}\PY{p}{,}\PY{n}{y1}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x1}\PY{o}{+}\PY{n}{w1}\PY{p}{,}\PY{n}{y1}\PY{o}{+}\PY{n}{h1}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the image with both faces and eyes detected}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Image with Face and Eye Detection}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}10}]:} <matplotlib.image.AxesImage at 0x11a09bb50>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_17_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsection{(Optional) Add face and eye detection to your laptop
camera}\label{optional-add-face-and-eye-detection-to-your-laptop-camera}

It's time to kick it up a notch, and add face and eye detection to your
laptop's camera! Afterwards, you'll be able to show off your creation
like in the gif shown below - made with a completed version of the code!

Notice that not all of the detections here are perfect - and your result
need not be perfect either. You should spend a small amount of time
tuning the parameters of your detectors to get reasonable results, but
don't hold out for perfection. If we wanted perfection we'd need to
spend a ton of time tuning the parameters of each detector, cleaning up
the input image frames, etc. You can think of this as more of a rapid
prototype.

The next cell contains code for a wrapper function called
\texttt{laptop\_camera\_face\_eye\_detector} that, when called, will
activate your laptop's camera. You will place the relevant face and eye
detection code in this wrapper function to implement face/eye detection
and mark those detections on each image frame that your camera captures.

Before adding anything to the function, you can run it to get an idea of
how it works - a small window should pop up showing you the live feed
from your camera; you can press any key to close this window.

\textbf{Note:} Mac users may find that activating this function kills
the kernel of their notebook every once in a while. If this happens to
you, just restart your notebook's kernel, activate cell(s) containing
any crucial import statements, and you'll be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Add face and eye detection to this laptop camera function }
         \PY{c+c1}{\PYZsh{} Make sure to draw out all faces/eyes found in each frame on the shown video feed}
         
         \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time} 
         \PY{k}{def} \PY{n+nf}{detect\PYZus{}face}\PY{p}{(}\PY{n}{frame}\PY{p}{)}\PY{p}{:}
             \PY{n}{image} \PY{o}{=} \PY{n}{frame}
             \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
             \PY{n}{face\PYZus{}cascadeV} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
             
             \PY{n}{facesV} \PY{o}{=} \PY{n}{face\PYZus{}cascadeV}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
             \PY{n}{eye\PYZus{}cascadeV} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}eye.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             
             \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{facesV}\PY{p}{:}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}  
                 \PY{n}{roi\PYZus{}gray} \PY{o}{=} \PY{n}{gray}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
                 \PY{n}{roi\PYZus{}color} \PY{o}{=} \PY{n}{image}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
                 \PY{n}{eyesV} \PY{o}{=} \PY{n}{eye\PYZus{}cascadeV}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{roi\PYZus{}gray}\PY{p}{)}
                 \PY{k}{for} \PY{p}{(}\PY{n}{x1}\PY{p}{,}\PY{n}{y1}\PY{p}{,}\PY{n}{w1}\PY{p}{,}\PY{n}{h1}\PY{p}{)} \PY{o+ow}{in} \PY{n}{eyesV}\PY{p}{:}
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{roi\PYZus{}color}\PY{p}{,}\PY{p}{(}\PY{n}{x1}\PY{p}{,}\PY{n}{y1}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x1}\PY{o}{+}\PY{n}{w1}\PY{p}{,}\PY{n}{y1}\PY{o}{+}\PY{n}{h1}\PY{p}{)}\PY{p}{,}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
                     
             \PY{k}{return} \PY{n}{image}
                     
         \PY{c+c1}{\PYZsh{} wrapper function for face/eye detection with your laptop camera}
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{n+nb+bp}{False}
             
             \PY{c+c1}{\PYZsh{} Keep the video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Plot the image from camera with all the face and eye detections marked}
                 \PY{n}{frame} \PY{o}{=} \PY{n}{detect\PYZus{}face}\PY{p}{(}\PY{n}{frame}\PY{p}{)}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} Exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} Destroy windows }
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{c+c1}{\PYZsh{} Make sure window closes on OSx}
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} Read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}    
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{c+c1}{\PYZsh{} Call the laptop camera face/eye detector function above}
         \PY{n}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 2: De-noise an Image for Better Face
Detection}\label{step-2-de-noise-an-image-for-better-face-detection}

    Image quality is an important aspect of any computer vision task.
Typically, when creating a set of images to train a deep learning
network, significant care is taken to ensure that training images are
free of visual noise or artifacts that hinder object detection. While
computer vision algorithms - like a face detector - are typically
trained on 'nice' data such as this, new test data doesn't always look
so nice!

When applying a trained computer vision algorithm to a new piece of test
data one often cleans it up first before feeding it in. This sort of
cleaning - referred to as \emph{pre-processing} - can include a number
of cleaning phases like blurring, de-noising, color transformations,
etc., and many of these tasks can be accomplished using OpenCV.

In this short subsection we explore OpenCV's noise-removal functionality
to see how we can clean up a noisy image, which we then feed into our
trained face detector.

    \subsubsection{Create a noisy image to work
with}\label{create-a-noisy-image-to-work-with}

In the next cell, we create an artificial noisy version of the previous
multi-face image. This is a little exaggerated - we don't typically get
images that are this noisy - but
\href{https://digital-photography-school.com/how-to-avoid-and-reduce-noise-in-your-images/}{image
noise}, or 'grainy-ness' in a digitial image - is a fairly common
phenomenon.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{c+c1}{\PYZsh{} Load in the multi\PYZhy{}face test image again}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/test\PYZus{}image\PYZus{}1.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image copy to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Make an array copy of this image}
         \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{asarray}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Create noise \PYZhy{} here we add noise sampled randomly from a Gaussian distribution: a common model for noise}
         \PY{n}{noise\PYZus{}level} \PY{o}{=} \PY{l+m+mi}{40}
         \PY{n}{noise} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{randn}\PY{p}{(}\PY{n}{image}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{image}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{image}\PY{o}{.}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{n}{noise\PYZus{}level}
         
         \PY{c+c1}{\PYZsh{} Add this noise to the array image copy}
         \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{=} \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{+} \PY{n}{noise}
         
         \PY{c+c1}{\PYZsh{} Convert back to uint8 format}
         \PY{n}{image\PYZus{}with\PYZus{}noise} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{asarray}\PY{p}{(}\PY{p}{[}\PY{n}{np}\PY{o}{.}\PY{n}{uint8}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{clip}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{255}\PY{p}{)}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{]}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot our noisy image!}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Noisy Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}16}]:} <matplotlib.image.AxesImage at 0x11a070810>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_24_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    In the context of face detection, the problem with an image like this is
that - due to noise - we may miss some faces or get false detections.

In the next cell we apply the same trained OpenCV detector with the same
settings as before, to see what sort of detections we get.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{} Convert the RGB  image to grayscale}
         \PY{n}{gray\PYZus{}noise} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Extract the pre\PYZhy{}trained face detector from an xml file}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Detect the faces in image}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray\PYZus{}noise}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Print the number of faces detected in the image}
         \PY{k}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Make a copy of the orginal image to draw face detections on}
         \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
             
         
         \PY{c+c1}{\PYZsh{} Display the image with the detections}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Noisy Image with Face Detections}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
('Number of faces detected:', 11)

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}17}]:} <matplotlib.image.AxesImage at 0x12226d610>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_26_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    With this added noise we now miss one of the faces!

    \subsubsection{(IMPLEMENTATION) De-noise this image for better face
detection}\label{implementation-de-noise-this-image-for-better-face-detection}

Time to get your hands dirty: using OpenCV's built in color image
de-noising functionality called \texttt{fastNlMeansDenoisingColored} -
de-noise this image enough so that all the faces in the image are
properly detected. Once you have cleaned the image in the next cell, use
the cell that follows to run our trained face detector over the cleaned
image to check out its detections.

You can find its {[}official documentation
here{]}(\href{http://docs.opencv.org/trunk/d1/d79/group__photo__denoise.html\#ga21abc1c8b0e15f78cd3eff672cb6c476}{documentation
for denoising} and
\href{http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_photo/py_non_local_means/py_non_local_means.html}{a
useful example here}.

\textbf{Note:} you can keep all parameters \emph{except}
\texttt{photo\_render} fixed as shown in the second link above. Play
around with the value of this parameter - see how it affects the
resulting cleaned image.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Use OpenCV\PYZsq{}s built in color image de\PYZhy{}noising function to clean up our noisy image!}
         
         
         \PY{n}{denoised\PYZus{}image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{fastNlMeansDenoisingColored}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}noise}\PY{p}{,}\PY{n+nb+bp}{None}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{21}\PY{p}{)}
         
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{16}\PY{p}{,}\PY{l+m+mi}{16}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{denoised}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{denoised\PYZus{}image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}23}]:} <matplotlib.image.AxesImage at 0x1169378d0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_29_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{gray\PYZus{}denoise} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{denoised\PYZus{}image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray\PYZus{}denoise}\PY{p}{,} \PY{l+m+mf}{1.3}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         
         \PY{n}{finalimg} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{denoised\PYZus{}image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{finalimg}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
         
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{16}\PY{p}{,}\PY{l+m+mi}{16}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{final image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{finalimg}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}28}]:} <matplotlib.image.AxesImage at 0x1210fa9d0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_30_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 3: Blur an Image and Perform Edge
Detection}\label{step-3-blur-an-image-and-perform-edge-detection}

    Now that we have developed a simple pipeline for detecting faces using
OpenCV - let's start playing around with a few fun things we can do with
all those detected faces!

    \subsubsection{Importance of Blur in Edge
Detection}\label{importance-of-blur-in-edge-detection}

Edge detection is a concept that pops up almost everywhere in computer
vision applications, as edge-based features (as well as features built
on top of edges) are often some of the best features for e.g., object
detection and recognition problems.

Edge detection is a dimension reduction technique - by keeping only the
edges of an image we get to throw away a lot of non-discriminating
information. And typically the most useful kind of edge-detection is one
that preserves only the important, global structures (ignoring local
structures that aren't very discriminative). So removing local
structures / retaining global structures is a crucial pre-processing
step to performing edge detection in an image, and blurring can do just
that.

Below is an animated gif showing the result of an edge-detected cat
\href{https://en.wikipedia.org/wiki/Gaussian_blur\#Common_uses}{taken
from Wikipedia}, where the image is gradually blurred more and more
prior to edge detection. When the animation begins you can't quite make
out what it's a picture of, but as the animation evolves and local
structures are removed via blurring the cat becomes visible in the
edge-detected image.

Edge detection is a \textbf{convolution} performed on the image itself,
and you can read about Canny edge detection on
\href{http://docs.opencv.org/2.4/doc/tutorials/imgproc/imgtrans/canny_detector/canny_detector.html}{this
OpenCV documentation page}.

    \subsubsection{Canny edge detection}\label{canny-edge-detection}

In the cell below we load in a test image, then apply \emph{Canny edge
detection} on it. The original image is shown on the left panel of the
figure, while the edge-detected version of the image is shown on the
right. Notice how the result looks very busy - there are too many little
details preserved in the image before it is sent to the edge detector.
When applied in computer vision applications, edge detection should
preserve \emph{global} structure; doing away with local structures that
don't help describe what objects are in the image.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{c+c1}{\PYZsh{} Load in the image}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/fawzia.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert to grayscale}
         \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}  
         
         \PY{c+c1}{\PYZsh{} Perform Canny edge detection}
         \PY{n}{edges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{Canny}\PY{p}{(}\PY{n}{gray}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{200}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Dilate the image to amplify edges}
         \PY{n}{edges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{dilate}\PY{p}{(}\PY{n}{edges}\PY{p}{,} \PY{n+nb+bp}{None}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Plot the RGB and edge\PYZhy{}detected image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{121}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{n}{ax2} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{122}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Canny Edges}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{edges}\PY{p}{,} \PY{n}{cmap}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gray}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}29}]:} <matplotlib.image.AxesImage at 0x11adc6250>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_35_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Without first blurring the image, and removing small, local structures,
a lot of irrelevant edge content gets picked up and amplified by the
detector (as shown in the right panel above).

    \subsubsection{\texorpdfstring{(IMPLEMENTATION) Blur the image
\emph{then} perform edge
detection}{(IMPLEMENTATION) Blur the image then perform edge detection}}\label{implementation-blur-the-image-then-perform-edge-detection}

In the next cell, you will repeat this experiment - blurring the image
first to remove these local structures, so that only the important
boudnary details remain in the edge-detected image.

Blur the image by using OpenCV's \texttt{filter2d} functionality - which
is discussed in
\href{http://docs.opencv.org/3.1.0/d4/d13/tutorial_py_filtering.html}{this
documentation page} - and use an \emph{averaging kernel} of width equal
to 4.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} TODO: Blur the test imageusing OpenCV\PYZsq{}s filter2d functionality, }
         \PY{c+c1}{\PYZsh{} Use an averaging kernel, and a kernel width equal to 4}
         \PY{n}{orig\PYZus{}img} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{n}{kernel} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{16}
         
         \PY{n}{blur} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{filter2D}\PY{p}{(}\PY{n}{orig\PYZus{}img}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{kernel}\PY{p}{)}
         
         \PY{n}{grayBlur} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{blur}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Then perform Canny edge detection and display the output}
         \PY{n}{blurEdges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{Canny}\PY{p}{(}\PY{n}{grayBlur}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{200}\PY{p}{)}
         
         \PY{n}{blurEdges} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{dilate}\PY{p}{(}\PY{n}{blurEdges}\PY{p}{,} \PY{n+nb+bp}{None}\PY{p}{)}
         
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{15}\PY{p}{,}\PY{l+m+mi}{15}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{121}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Blurred}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{blur}\PY{p}{)}
         
         \PY{n}{ax2} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{122}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         
         \PY{n}{ax2}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Edges}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{blurEdges}\PY{p}{,} \PY{n}{cmap}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{gray}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}30}]:} <matplotlib.image.AxesImage at 0x11b94ec50>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_38_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 4: Automatically Hide the Identity of an
Individual}\label{step-4-automatically-hide-the-identity-of-an-individual}

If you film something like a documentary or reality TV, you must get
permission from every individual shown on film before you can show their
face, otherwise you need to blur it out - by blurring the face a lot (so
much so that even the global structures are obscured)! This is also true
for projects like \href{https://www.google.com/streetview/}{Google's
StreetView maps} - an enormous collection of mapping images taken from a
fleet of Google vehicles. Because it would be impossible for Google to
get the permission of every single person accidentally captured in one
of these images they blur out everyone's faces, the detected images must
automatically blur the identity of detected people. Here's a few
examples of folks caught in the camera of a Google street view vehicle.

 

    \subsubsection{Read in an image to perform identity
detection}\label{read-in-an-image-to-perform-identity-detection}

Let's try this out for ourselves. Use the face detection pipeline built
above and what you know about using the \texttt{filter2D} to blur and
image, and use these in tandem to hide the identity of the person in the
following image - loaded in and printed in the next cell.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}66}]:} \PY{c+c1}{\PYZsh{} Load in the image}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/gus.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} Display the image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}66}]:} <matplotlib.image.AxesImage at 0x14552fb90>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_41_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{(IMPLEMENTATION) Use blurring to hide the identity of an
individual in an
image}\label{implementation-use-blurring-to-hide-the-identity-of-an-individual-in-an-image}

The idea here is to 1) automatically detect the face in this image, and
then 2) blur it out! Make sure to adjust the parameters of the
\emph{averaging} blur filter to completely obscure this person's
identity.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}68}]:} \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Implement face detection}
         \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.35}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         \PY{k}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         \PY{n}{kernel\PYZus{}2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{40}\PY{p}{,}\PY{l+m+mi}{40}\PY{p}{)}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{1600}   
         
         \PY{n}{result} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{result}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
         \PY{c+c1}{\PYZsh{} \PYZsh{}\PYZsh{} TODO: Blur the bounding box around each detected face using an averaging filter and display the result}
             \PY{n}{copy} \PY{o}{=} \PY{n}{image}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
             \PY{n}{blur} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{filter2D}\PY{p}{(}\PY{n}{copy}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{kernel\PYZus{}2}\PY{p}{)}
             \PY{n}{result}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]} \PY{o}{=} \PY{n}{blur}
         
         
         
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{grey}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{result}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
('Number of faces detected:', 1)

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}68}]:} <matplotlib.image.AxesImage at 0x1453163d0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_43_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{(Optional) Build identity protection into your laptop
camera}\label{optional-build-identity-protection-into-your-laptop-camera}

In this optional task you can add identity protection to your laptop
camera, using the previously completed code where you added face
detection to your laptop camera - and the task above. You should be able
to get reasonable results with little parameter tuning - like the one
shown in the gif below.

As with the previous video task, to make this perfect would require
significant effort - so don't strive for perfection here, strive for
reasonable quality.

The next cell contains code a wrapper function called
\texttt{laptop\_camera\_identity\_hider} that - when called - will
activate your laptop's camera. You need to place the relevant face
detection and blurring code developed above in this function in order to
blur faces entering your laptop camera's field of view.

Before adding anything to the function you can call it to get a hang of
how it works - a small window will pop up showing you the live feed from
your camera, you can press any key to close this window.

\textbf{Note:} Mac users may find that activating this function kills
the kernel of their notebook every once in a while. If this happens to
you, just restart your notebook's kernel, activate cell(s) containing
any crucial import statements, and you'll be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}73}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Insert face detection and blurring code into the wrapper below to create an identity protector on your laptop!}
         \PY{k+kn}{import} \PY{n+nn}{cv2}
         \PY{k+kn}{import} \PY{n+nn}{time}
         
         \PY{k}{def} \PY{n+nf}{blur\PYZus{}face}\PY{p}{(}\PY{n}{frame}\PY{p}{)}\PY{p}{:}
             \PY{n}{image} \PY{o}{=} \PY{n}{frame}
             \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}RGB2GRAY}\PY{p}{)}
             \PY{n}{face\PYZus{}cascade} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
             \PY{n}{result} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
             \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.25}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
             \PY{n}{kernel\PYZus{}2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{ones}\PY{p}{(}\PY{p}{(}\PY{l+m+mi}{40}\PY{p}{,}\PY{l+m+mi}{40}\PY{p}{)}\PY{p}{,}\PY{n}{np}\PY{o}{.}\PY{n}{float32}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{1600}   
             
             \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
         \PY{c+c1}{\PYZsh{}         cv2.rectangle(image, (x,y), (x+w,y+h),(255,0,0), 3)  }
                 \PY{n}{copy} \PY{o}{=} \PY{n}{image}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]}
                 \PY{n}{blur} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{filter2D}\PY{p}{(}\PY{n}{copy}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{n}{kernel\PYZus{}2}\PY{p}{)}
                 \PY{n}{result}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]} \PY{o}{=} \PY{n}{blur}   
             \PY{k}{return} \PY{n}{result}
         
         \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
             \PY{c+c1}{\PYZsh{} Create instance of video capturer}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
             \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
         
             \PY{c+c1}{\PYZsh{} Try to get the first frame}
             \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
             \PY{k}{else}\PY{p}{:}
                 \PY{n}{rval} \PY{o}{=} \PY{n+nb+bp}{False}
             
             \PY{c+c1}{\PYZsh{} Keep video stream open}
             \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                 \PY{c+c1}{\PYZsh{} Plot image from camera with detections marked}
                 \PY{n}{frame} \PY{o}{=} \PY{n}{blur\PYZus{}face}\PY{p}{(}\PY{n}{frame}\PY{p}{)}
                 \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                 
                 \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                 \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                 \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} Exit by pressing any key}
                     \PY{c+c1}{\PYZsh{} Destroy windows}
                     \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                     
                     \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                         \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                     \PY{k}{return}
                 
                 \PY{c+c1}{\PYZsh{} Read next frame}
                 \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                 \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}    
                 
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}74}]:} \PY{c+c1}{\PYZsh{} Run laptop identity hider}
         \PY{n}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 5: Create a CNN to Recognize Facial
Keypoints}\label{step-5-create-a-cnn-to-recognize-facial-keypoints}

OpenCV is often used in practice with other machine learning and deep
learning libraries to produce interesting results. In this stage of the
project you will create your own end-to-end pipeline - employing
convolutional networks in keras along with OpenCV - to apply a "selfie"
filter to streaming video and images.

You will start by creating and then training a convolutional network
that can detect facial keypoints in a small dataset of cropped images of
human faces. We then guide you towards OpenCV to expanding your
detection algorithm to more general images. What are facial keypoints?
Let's take a look at some examples.

Facial keypoints (also called facial landmarks) are the small blue-green
dots shown on each of the faces in the image above - there are 15
keypoints marked in each image. They mark important areas of the face -
the eyes, corners of the mouth, the nose, etc. Facial keypoints can be
used in a variety of machine learning applications from face and emotion
recognition to commercial applications like the image filters
popularized by Snapchat.

Below we illustrate a filter that, using the results of this section,
automatically places sunglasses on people in images (using the facial
keypoints to place the glasses correctly on each face). Here, the facial
keypoints have been colored lime green for visualization purposes.

    \subsubsection{Make a facial keypoint
detector}\label{make-a-facial-keypoint-detector}

But first things first: how can we make a facial keypoint detector?
Well, at a high level, notice that facial keypoint detection is a
\emph{regression problem}. A single face corresponds to a set of 15
facial keypoints (a set of 15 corresponding \((x, y)\) coordinates,
i.e., an output point). Because our input data are images, we can employ
a \emph{convolutional neural network} to recognize patterns in our
images and learn how to identify these keypoint given sets of labeled
data.

In order to train a regressor, we need a training set - a set of facial
image / facial keypoint pairs to train on. For this we will be using
\href{https://www.kaggle.com/c/facial-keypoints-detection/data}{this
dataset from Kaggle}. We've already downloaded this data and placed it
in the \texttt{data} directory. Make sure that you have both the
\emph{training} and \emph{test} data files. The training dataset
contains several thousand \(96 \times 96\) grayscale images of cropped
human faces, along with each face's 15 corresponding facial keypoints
(also called landmarks) that have been placed by hand, and recorded in
\((x, y)\) coordinates. This wonderful resource also has a substantial
testing set, which we will use in tinkering with our convolutional
network.

To load in this data, run the Python cell below - notice we will load in
both the training and testing sets.

The \texttt{load\_data} function is in the included \texttt{utils.py}
file.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{from} \PY{n+nn}{utils} \PY{k+kn}{import} \PY{o}{*}
        
        \PY{c+c1}{\PYZsh{} Load training set}
        \PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{y\PYZus{}train} \PY{o}{=} \PY{n}{load\PYZus{}data}\PY{p}{(}\PY{p}{)}
        \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X\PYZus{}train.shape == \PYZob{}\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
        \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y\PYZus{}train.shape == \PYZob{}\PYZcb{}; y\PYZus{}train.min == \PYZob{}:.3f\PYZcb{}; y\PYZus{}train.max == \PYZob{}:.3f\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}
            \PY{n}{y\PYZus{}train}\PY{o}{.}\PY{n}{shape}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{o}{.}\PY{n}{min}\PY{p}{(}\PY{p}{)}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{o}{.}\PY{n}{max}\PY{p}{(}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Load testing set}
        \PY{n}{X\PYZus{}test}\PY{p}{,} \PY{n}{\PYZus{}} \PY{o}{=} \PY{n}{load\PYZus{}data}\PY{p}{(}\PY{n}{test}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}
        \PY{k}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X\PYZus{}test.shape == \PYZob{}\PYZcb{}}\PY{l+s+s2}{\PYZdq{}}\PY{o}{.}\PY{n}{format}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{o}{.}\PY{n}{shape}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
/anaconda2/lib/python2.7/site-packages/h5py/\_\_init\_\_.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
  from .\_conv import register\_converters as \_register\_converters
Using TensorFlow backend.

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
X\_train.shape == (2140, 96, 96, 1)
y\_train.shape == (2140, 30); y\_train.min == -0.920; y\_train.max == 0.996
X\_test.shape == (1783, 96, 96, 1)

    \end{Verbatim}

    The \texttt{load\_data} function in \texttt{utils.py} originates from
this excellent
\href{http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/}{blog
post}, which you are \emph{strongly} encouraged to read. Please take the
time now to review this function. Note how the output values - that is,
the coordinates of each set of facial landmarks - have been normalized
to take on values in the range \([-1, 1]\), while the pixel values of
each input point (a facial image) have been normalized to the range
\([0,1]\).

Note: the original Kaggle dataset contains some images with several
missing keypoints. For simplicity, the \texttt{load\_data} function
removes those images with missing labels from the dataset. As an
\textbf{\emph{optional}} extension, you are welcome to amend the
\texttt{load\_data} function to include the incomplete data points.

    \subsubsection{Visualize the Training
Data}\label{visualize-the-training-data}

Execute the code cell below to visualize a subset of the training data.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{k+kn}{import} \PY{n+nn}{matplotlib.pyplot} \PY{k+kn}{as} \PY{n+nn}{plt}
        \PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
        
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}
        \PY{n}{fig}\PY{o}{.}\PY{n}{subplots\PYZus{}adjust}\PY{p}{(}\PY{n}{left}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{right}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{bottom}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{top}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{hspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,} \PY{n}{wspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{)}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
            \PY{n}{ax} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{xticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{n}{yticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{)}
            \PY{n}{plot\PYZus{}data}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{ax}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_52_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    For each training image, there are two landmarks per eyebrow
(\textbf{four} total), three per eye (\textbf{six} total), \textbf{four}
for the mouth, and \textbf{one} for the tip of the nose.

Review the \texttt{plot\_data} function in \texttt{utils.py} to
understand how the 30-dimensional training labels in \texttt{y\_train}
are mapped to facial locations, as this function will prove useful for
your pipeline.

    \subsubsection{(IMPLEMENTATION) Specify the CNN
Architecture}\label{implementation-specify-the-cnn-architecture}

In this section, you will specify a neural network for predicting the
locations of facial keypoints. Use the code cell below to specify the
architecture of your neural network. We have imported some layers that
you may find useful for this task, but if you need to use more Keras
layers, feel free to import them in the cell.

Your network should accept a \(96 \times 96\) grayscale image as input,
and it should output a vector with 30 entries, corresponding to the
predicted (horizontal and vertical) locations of 15 facial keypoints. If
you are not sure where to start, you can find some useful starting
architectures in
\href{http://danielnouri.org/notes/2014/12/17/using-convolutional-neural-nets-to-detect-facial-keypoints-tutorial/}{this
blog}, but you are not permitted to copy any of the architectures that
you find online.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} Import deep learning resources from Keras}
        \PY{k+kn}{from} \PY{n+nn}{keras.models} \PY{k+kn}{import} \PY{n}{Sequential}
        \PY{k+kn}{from} \PY{n+nn}{keras.layers} \PY{k+kn}{import} \PY{n}{Convolution2D}\PY{p}{,} \PY{n}{MaxPooling2D}\PY{p}{,} \PY{n}{Dropout}
        \PY{k+kn}{from} \PY{n+nn}{keras.layers} \PY{k+kn}{import} \PY{n}{Flatten}\PY{p}{,} \PY{n}{Dense}
        
        
        \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Specify a CNN architecture}
        \PY{c+c1}{\PYZsh{} Your model should accept 96x96 pixel graysale images in}
        \PY{c+c1}{\PYZsh{} It should have a fully\PYZhy{}connected output layer with 30 values (2 for each facial keypoint)}
        
        \PY{n}{model} \PY{o}{=} \PY{n}{Sequential}\PY{p}{(}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{16}\PY{p}{,} \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{input\PYZus{}shape}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{96}\PY{p}{,} \PY{l+m+mi}{96}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{32}\PY{p}{,} \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{64}\PY{p}{,} \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Convolution2D}\PY{p}{(}\PY{n}{filters}\PY{o}{=}\PY{l+m+mi}{128}\PY{p}{,} \PY{n}{kernel\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{padding}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{same}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{MaxPooling2D}\PY{p}{(}\PY{n}{pool\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Flatten}\PY{p}{(}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dense}\PY{p}{(}\PY{l+m+mi}{500}\PY{p}{,} \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.1}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dense}\PY{p}{(}\PY{l+m+mi}{500}\PY{p}{,} \PY{n}{activation}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{relu}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dropout}\PY{p}{(}\PY{l+m+mf}{0.2}\PY{p}{)}\PY{p}{)}
        \PY{n}{model}\PY{o}{.}\PY{n}{add}\PY{p}{(}\PY{n}{Dense}\PY{p}{(}\PY{l+m+mi}{30}\PY{p}{)}\PY{p}{)}
        
        
        \PY{c+c1}{\PYZsh{} Summarize the model}
        \PY{n}{model}\PY{o}{.}\PY{n}{summary}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
Layer (type)                 Output Shape              Param \#   
=================================================================
conv2d\_1 (Conv2D)            (None, 96, 96, 16)        160       
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_1 (MaxPooling2 (None, 48, 48, 16)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_2 (Conv2D)            (None, 48, 48, 32)        4640      
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_2 (MaxPooling2 (None, 24, 24, 32)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_3 (Conv2D)            (None, 24, 24, 64)        8256      
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_3 (MaxPooling2 (None, 12, 12, 64)        0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
conv2d\_4 (Conv2D)            (None, 12, 12, 128)       32896     
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
max\_pooling2d\_4 (MaxPooling2 (None, 6, 6, 128)         0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
flatten\_1 (Flatten)          (None, 4608)              0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_1 (Dropout)          (None, 4608)              0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dense\_1 (Dense)              (None, 500)               2304500   
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_2 (Dropout)          (None, 500)               0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dense\_2 (Dense)              (None, 500)               250500    
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dropout\_3 (Dropout)          (None, 500)               0         
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
dense\_3 (Dense)              (None, 30)                15030     
=================================================================
Total params: 2,615,982
Trainable params: 2,615,982
Non-trainable params: 0
\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_

    \end{Verbatim}

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 6: Compile and Train the
Model}\label{step-6-compile-and-train-the-model}

After specifying your architecture, you'll need to compile and train the
model to detect facial keypoints'

    \subsubsection{(IMPLEMENTATION) Compile and Train the
Model}\label{implementation-compile-and-train-the-model}

Use the \texttt{compile}
\href{https://keras.io/models/sequential/\#sequential-model-methods}{method}
to configure the learning process. Experiment with your choice of
\href{https://keras.io/optimizers/}{optimizer}; you may have some ideas
about which will work best (\texttt{SGD} vs. \texttt{RMSprop}, etc), but
take the time to empirically verify your theories.

Use the \texttt{fit}
\href{https://keras.io/models/sequential/\#sequential-model-methods}{method}
to train the model. Break off a validation set by setting
\texttt{validation\_split=0.2}. Save the returned \texttt{History}
object in the \texttt{history} variable.

Experiment with your model to minimize the validation loss (measured as
mean squared error). A very good model will achieve about 0.0015 loss
(though it's possible to do even better). When you have finished
training,
\href{https://keras.io/getting-started/faq/\#how-can-i-save-a-keras-model}{save
your model} as an HDF5 file with file path \texttt{my\_model.h5}.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{k+kn}{from} \PY{n+nn}{keras.optimizers} \PY{k+kn}{import} \PY{n}{SGD}\PY{p}{,} \PY{n}{RMSprop}\PY{p}{,} \PY{n}{Adagrad}\PY{p}{,} \PY{n}{Adadelta}\PY{p}{,} \PY{n}{Adam}\PY{p}{,} \PY{n}{Adamax}\PY{p}{,} \PY{n}{Nadam}
        \PY{k+kn}{from} \PY{n+nn}{keras.callbacks} \PY{k+kn}{import} \PY{n}{ModelCheckpoint}
        
        \PY{n}{model}\PY{o}{.}\PY{n}{compile}\PY{p}{(}\PY{n}{loss}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mean\PYZus{}squared\PYZus{}error}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{optimizer}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Nadam}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{metrics}\PY{o}{=}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{accuracy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{)}
        
        \PY{n}{checkpointer} \PY{o}{=} \PY{n}{ModelCheckpoint}\PY{p}{(}\PY{n}{filepath}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.hdf5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{verbose}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{save\PYZus{}best\PYZus{}only}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}
        
        \PY{n}{hist} \PY{o}{=} \PY{n}{model}\PY{o}{.}\PY{n}{fit}\PY{p}{(}\PY{n}{X\PYZus{}train}\PY{p}{,} \PY{n}{y\PYZus{}train}\PY{p}{,} \PY{n}{batch\PYZus{}size}\PY{o}{=}\PY{l+m+mi}{40}\PY{p}{,} \PY{n}{epochs}\PY{o}{=}\PY{l+m+mi}{50}\PY{p}{,}\PY{n}{validation\PYZus{}split}\PY{o}{=}\PY{l+m+mf}{0.2}\PY{p}{,} \PY{n}{callbacks}\PY{o}{=}\PY{p}{[}\PY{n}{checkpointer}\PY{p}{]}\PY{p}{,} \PY{n}{verbose}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{shuffle}\PY{o}{=}\PY{n+nb+bp}{True}\PY{p}{)}
        \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Save the model as model.h5}
        \PY{n}{model}\PY{o}{.}\PY{n}{save}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.h5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Train on 1712 samples, validate on 428 samples
Epoch 1/50
 - 23s - loss: 0.0355 - acc: 0.5058 - val\_loss: 0.0097 - val\_acc: 0.6963

Epoch 00001: val\_loss improved from inf to 0.00972, saving model to my\_model.hdf5
Epoch 2/50
 - 23s - loss: 0.0084 - acc: 0.6396 - val\_loss: 0.0072 - val\_acc: 0.6963

Epoch 00002: val\_loss improved from 0.00972 to 0.00722, saving model to my\_model.hdf5
Epoch 3/50
 - 24s - loss: 0.0069 - acc: 0.6530 - val\_loss: 0.0045 - val\_acc: 0.6963

Epoch 00003: val\_loss improved from 0.00722 to 0.00449, saving model to my\_model.hdf5
Epoch 4/50
 - 23s - loss: 0.0059 - acc: 0.6887 - val\_loss: 0.0058 - val\_acc: 0.6963

Epoch 00004: val\_loss did not improve
Epoch 5/50
 - 24s - loss: 0.0054 - acc: 0.6846 - val\_loss: 0.0042 - val\_acc: 0.6963

Epoch 00005: val\_loss improved from 0.00449 to 0.00422, saving model to my\_model.hdf5
Epoch 6/50
 - 24s - loss: 0.0050 - acc: 0.6980 - val\_loss: 0.0036 - val\_acc: 0.6963

Epoch 00006: val\_loss improved from 0.00422 to 0.00363, saving model to my\_model.hdf5
Epoch 7/50
 - 23s - loss: 0.0047 - acc: 0.7056 - val\_loss: 0.0041 - val\_acc: 0.6963

Epoch 00007: val\_loss did not improve
Epoch 8/50
 - 23s - loss: 0.0042 - acc: 0.6974 - val\_loss: 0.0033 - val\_acc: 0.6963

Epoch 00008: val\_loss improved from 0.00363 to 0.00327, saving model to my\_model.hdf5
Epoch 9/50
 - 23s - loss: 0.0038 - acc: 0.7039 - val\_loss: 0.0035 - val\_acc: 0.6939

Epoch 00009: val\_loss did not improve
Epoch 10/50
 - 23s - loss: 0.0032 - acc: 0.6957 - val\_loss: 0.0025 - val\_acc: 0.7103

Epoch 00010: val\_loss improved from 0.00327 to 0.00252, saving model to my\_model.hdf5
Epoch 11/50
 - 23s - loss: 0.0030 - acc: 0.7138 - val\_loss: 0.0025 - val\_acc: 0.7056

Epoch 00011: val\_loss improved from 0.00252 to 0.00250, saving model to my\_model.hdf5
Epoch 12/50
 - 23s - loss: 0.0027 - acc: 0.7220 - val\_loss: 0.0020 - val\_acc: 0.7220

Epoch 00012: val\_loss improved from 0.00250 to 0.00203, saving model to my\_model.hdf5
Epoch 13/50
 - 23s - loss: 0.0024 - acc: 0.7266 - val\_loss: 0.0020 - val\_acc: 0.7150

Epoch 00013: val\_loss improved from 0.00203 to 0.00198, saving model to my\_model.hdf5
Epoch 14/50
 - 23s - loss: 0.0022 - acc: 0.7296 - val\_loss: 0.0017 - val\_acc: 0.7383

Epoch 00014: val\_loss improved from 0.00198 to 0.00171, saving model to my\_model.hdf5
Epoch 15/50
 - 23s - loss: 0.0021 - acc: 0.7336 - val\_loss: 0.0018 - val\_acc: 0.7313

Epoch 00015: val\_loss did not improve
Epoch 16/50
 - 24s - loss: 0.0020 - acc: 0.7453 - val\_loss: 0.0020 - val\_acc: 0.7243

Epoch 00016: val\_loss did not improve
Epoch 17/50
 - 24s - loss: 0.0018 - acc: 0.7412 - val\_loss: 0.0015 - val\_acc: 0.7360

Epoch 00017: val\_loss improved from 0.00171 to 0.00149, saving model to my\_model.hdf5
Epoch 18/50
 - 24s - loss: 0.0017 - acc: 0.7558 - val\_loss: 0.0014 - val\_acc: 0.7500

Epoch 00018: val\_loss improved from 0.00149 to 0.00144, saving model to my\_model.hdf5
Epoch 19/50
 - 24s - loss: 0.0016 - acc: 0.7494 - val\_loss: 0.0014 - val\_acc: 0.7593

Epoch 00019: val\_loss improved from 0.00144 to 0.00136, saving model to my\_model.hdf5
Epoch 20/50
 - 23s - loss: 0.0015 - acc: 0.7710 - val\_loss: 0.0016 - val\_acc: 0.7500

Epoch 00020: val\_loss did not improve
Epoch 21/50
 - 24s - loss: 0.0014 - acc: 0.7734 - val\_loss: 0.0014 - val\_acc: 0.7570

Epoch 00021: val\_loss did not improve
Epoch 22/50
 - 23s - loss: 0.0014 - acc: 0.7868 - val\_loss: 0.0016 - val\_acc: 0.7523

Epoch 00022: val\_loss did not improve
Epoch 23/50
 - 23s - loss: 0.0014 - acc: 0.7704 - val\_loss: 0.0016 - val\_acc: 0.7617

Epoch 00023: val\_loss did not improve
Epoch 24/50
 - 23s - loss: 0.0014 - acc: 0.7734 - val\_loss: 0.0013 - val\_acc: 0.7687

Epoch 00024: val\_loss improved from 0.00136 to 0.00132, saving model to my\_model.hdf5
Epoch 25/50
 - 23s - loss: 0.0013 - acc: 0.7786 - val\_loss: 0.0014 - val\_acc: 0.7850

Epoch 00025: val\_loss did not improve
Epoch 26/50
 - 24s - loss: 0.0013 - acc: 0.7839 - val\_loss: 0.0014 - val\_acc: 0.7780

Epoch 00026: val\_loss did not improve
Epoch 27/50
 - 23s - loss: 0.0012 - acc: 0.7886 - val\_loss: 0.0013 - val\_acc: 0.7687

Epoch 00027: val\_loss improved from 0.00132 to 0.00126, saving model to my\_model.hdf5
Epoch 28/50
 - 23s - loss: 0.0012 - acc: 0.7967 - val\_loss: 0.0013 - val\_acc: 0.7477

Epoch 00028: val\_loss did not improve
Epoch 29/50
 - 23s - loss: 0.0012 - acc: 0.7950 - val\_loss: 0.0012 - val\_acc: 0.7850

Epoch 00029: val\_loss improved from 0.00126 to 0.00118, saving model to my\_model.hdf5
Epoch 30/50
 - 23s - loss: 0.0011 - acc: 0.8107 - val\_loss: 0.0012 - val\_acc: 0.7874

Epoch 00030: val\_loss did not improve
Epoch 31/50
 - 25s - loss: 0.0011 - acc: 0.8096 - val\_loss: 0.0012 - val\_acc: 0.7804

Epoch 00031: val\_loss improved from 0.00118 to 0.00118, saving model to my\_model.hdf5
Epoch 32/50
 - 25s - loss: 0.0010 - acc: 0.8078 - val\_loss: 0.0012 - val\_acc: 0.7944

Epoch 00032: val\_loss did not improve
Epoch 33/50
 - 24s - loss: 0.0011 - acc: 0.8055 - val\_loss: 0.0012 - val\_acc: 0.7780

Epoch 00033: val\_loss did not improve
Epoch 34/50
 - 25s - loss: 0.0010 - acc: 0.8072 - val\_loss: 0.0014 - val\_acc: 0.7921

Epoch 00034: val\_loss did not improve
Epoch 35/50
 - 25s - loss: 0.0010 - acc: 0.8178 - val\_loss: 0.0012 - val\_acc: 0.7921

Epoch 00035: val\_loss improved from 0.00118 to 0.00116, saving model to my\_model.hdf5
Epoch 36/50
 - 28s - loss: 0.0010 - acc: 0.8119 - val\_loss: 0.0011 - val\_acc: 0.7991

Epoch 00036: val\_loss improved from 0.00116 to 0.00112, saving model to my\_model.hdf5
Epoch 37/50
 - 26s - loss: 9.7610e-04 - acc: 0.8107 - val\_loss: 0.0012 - val\_acc: 0.7897

Epoch 00037: val\_loss did not improve
Epoch 38/50
 - 27s - loss: 9.9891e-04 - acc: 0.8125 - val\_loss: 0.0012 - val\_acc: 0.7967

Epoch 00038: val\_loss did not improve
Epoch 39/50
 - 27s - loss: 9.5587e-04 - acc: 0.8289 - val\_loss: 0.0012 - val\_acc: 0.7827

Epoch 00039: val\_loss did not improve
Epoch 40/50
 - 24s - loss: 9.4961e-04 - acc: 0.8248 - val\_loss: 0.0013 - val\_acc: 0.7897

Epoch 00040: val\_loss did not improve
Epoch 41/50
 - 23s - loss: 9.1609e-04 - acc: 0.8148 - val\_loss: 0.0011 - val\_acc: 0.7874

Epoch 00041: val\_loss improved from 0.00112 to 0.00111, saving model to my\_model.hdf5
Epoch 42/50
 - 23s - loss: 8.6169e-04 - acc: 0.8201 - val\_loss: 0.0011 - val\_acc: 0.7804

Epoch 00042: val\_loss did not improve
Epoch 43/50
 - 23s - loss: 8.9314e-04 - acc: 0.8178 - val\_loss: 0.0011 - val\_acc: 0.7897

Epoch 00043: val\_loss improved from 0.00111 to 0.00110, saving model to my\_model.hdf5
Epoch 44/50
 - 23s - loss: 8.9600e-04 - acc: 0.8213 - val\_loss: 0.0012 - val\_acc: 0.7710

Epoch 00044: val\_loss did not improve
Epoch 45/50
 - 23s - loss: 8.5878e-04 - acc: 0.8312 - val\_loss: 0.0012 - val\_acc: 0.7804

Epoch 00045: val\_loss did not improve
Epoch 46/50
 - 24s - loss: 8.1365e-04 - acc: 0.8312 - val\_loss: 0.0012 - val\_acc: 0.7897

Epoch 00046: val\_loss did not improve
Epoch 47/50
 - 23s - loss: 8.3878e-04 - acc: 0.8289 - val\_loss: 0.0011 - val\_acc: 0.7850

Epoch 00047: val\_loss did not improve
Epoch 48/50
 - 23s - loss: 8.0954e-04 - acc: 0.8265 - val\_loss: 0.0011 - val\_acc: 0.7780

Epoch 00048: val\_loss did not improve
Epoch 49/50
 - 23s - loss: 7.8771e-04 - acc: 0.8405 - val\_loss: 0.0011 - val\_acc: 0.7991

Epoch 00049: val\_loss did not improve
Epoch 50/50
 - 23s - loss: 8.3011e-04 - acc: 0.8376 - val\_loss: 0.0012 - val\_acc: 0.7593

Epoch 00050: val\_loss did not improve

    \end{Verbatim}

    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 7: Visualize the Loss and Test
Predictions}\label{step-7-visualize-the-loss-and-test-predictions}

    \subsubsection{(IMPLEMENTATION) Answer a few questions and visualize the
loss}\label{implementation-answer-a-few-questions-and-visualize-the-loss}

\textbf{Question 1:} Outline the steps you took to get to your final
neural network architecture and your reasoning at each step.

\textbf{Answer:} The architecture was that of a standard Convolution
Nueral Network consisting of convolutional layers and max pooling
layers, followed by a flattening layers and finally fully connected
dense layers. Since the training data was 96x96 pixels the number of
parameters was quite large for training on the CPU. Hence max pooling
layers were added after each convolution layer to reduce the number of
parameters.

The number of filters in each convolution layer has been doubled to
increase the depth of each convolution layer. The max pooling layers
after each convolution layer are necessary to reduce the number of
parameters as the model was trained on a CPU and not on a GPU.

The number of Dense layers and the dropout was experimented with. For
just 1 dense layer, the model started the overfit a lot around epoch 25.
So 2 dense layers were added. The probability for dropout was kept low
as it wasn,t necessary for the model in 50 epochs. However on models
where the filter size was larg dropout had to be increased.

\textbf{Question 2:} Defend your choice of optimizer. Which optimizers
did you test, and how did you determine which worked best?

\textbf{Answer:} RMSprop, Nadam and SGD were tried for the final
architecture. In 50 epochs Nadam reached a validation loss of 0.0010,
while RMSprop reached a validation loss of around 0.0014. SGD turned out
to be slower than RMSprop. Since the model was trained on just the CPU,
a lower number of epochs was more necessary. Hence Nadam was finally
chosen.

Use the code cell below to plot the training and validation loss of your
neural network. You may find
\href{http://machinelearningmastery.com/display-deep-learning-model-training-history-in-keras/}{this
resource} useful.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{c+c1}{\PYZsh{}\PYZsh{} TODO: Visualize the training and validation loss of your neural network}
         \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{12}\PY{p}{,}\PY{l+m+mi}{12}\PY{p}{)}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{50}\PY{p}{)}\PY{p}{,} \PY{n}{hist}\PY{o}{.}\PY{n}{history}\PY{p}{[}
                  \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{val\PYZus{}loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{g\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Val Loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{50}\PY{p}{)}\PY{p}{,} \PY{n}{hist}\PY{o}{.}\PY{n}{history}\PY{p}{[}
                  \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{g\PYZhy{}\PYZhy{}}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{label}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Train Loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{xlabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Epochs}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{ylabel}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Loss}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{legend}\PY{p}{(}\PY{p}{)}
         \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_61_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \textbf{Question 3:} Do you notice any evidence of overfitting or
underfitting in the above plot? If so, what steps have you taken to
improve your model? Note that slight overfitting or underfitting will
not hurt your chances of a successful submission, as long as you have
attempted some solutions towards improving your model (such as
\emph{regularization, dropout, increased/decreased number of layers,
etc}).

\textbf{Answer:} The model ran only for 50 epochs. However slight
overfitting starts somewhere between epoch 30-35. 3 dropout layers have
been added with parameter '0.2','0.1' and '0.2' respectively. However
effect of these dropout layers is not prominent until the filter size is
increased (tested on another model). However when the filter size is
increased, the overfitting becomes much more prominent.

    \subsubsection{Visualize a Subset of the Test
Predictions}\label{visualize-a-subset-of-the-test-predictions}

Execute the code cell below to visualize your model's predicted
keypoints on a subset of the testing images.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{y\PYZus{}test} \PY{o}{=} \PY{n}{model}\PY{o}{.}\PY{n}{predict}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{p}{)}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{)}\PY{p}{)}
         \PY{n}{fig}\PY{o}{.}\PY{n}{subplots\PYZus{}adjust}\PY{p}{(}\PY{n}{left}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{right}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{bottom}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{,} \PY{n}{top}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{hspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{,} \PY{n}{wspace}\PY{o}{=}\PY{l+m+mf}{0.05}\PY{p}{)}
         \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{:}
             \PY{n}{ax} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{,} \PY{n}{i} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{,} \PY{n}{xticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{n}{yticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{)}
             \PY{n}{plot\PYZus{}data}\PY{p}{(}\PY{n}{X\PYZus{}test}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{y\PYZus{}test}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,} \PY{n}{ax}\PY{p}{)}
\end{Verbatim}


    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_64_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Step 8: Complete the
pipeline}\label{step-8-complete-the-pipeline}

With the work you did in Sections 1 and 2 of this notebook, along with
your freshly trained facial keypoint detector, you can now complete the
full pipeline. That is given a color image containing a person or
persons you can now

\begin{itemize}
\tightlist
\item
  Detect the faces in this image automatically using OpenCV
\item
  Predict the facial keypoints in each face detected in the image
\item
  Paint predicted keypoints on each face detected
\end{itemize}

In this Subsection you will do just this!

    \subsubsection{(IMPLEMENTATION) Facial Keypoints
Detector}\label{implementation-facial-keypoints-detector}

Use the OpenCV face detection functionality you built in previous
Sections to expand the functionality of your keypoints detector to color
images with arbitrary size. Your function should perform the following
steps

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accept a color image.
\item
  Convert the image to grayscale.
\item
  Detect and crop the face contained in the image.
\item
  Locate the facial keypoints in the cropped image.
\item
  Overlay the facial keypoints in the original (color, uncropped) image.
\end{enumerate}

\textbf{Note}: step 4 can be the trickiest because remember your
convolutional network is only trained to detect facial keypoints in
\(96 \times 96\) grayscale images where each pixel was normalized to lie
in the interval \([0,1]\), and remember that each facial keypoint was
normalized during training to the interval \([-1,1]\). This means -
practically speaking - to paint detected keypoints onto a test face you
need to perform this same pre-processing to your candidate face - that
is after detecting it you should resize it to \(96 \times 96\) and
normalize its values before feeding it into your facial keypoint
detector. To be shown correctly on the original image the output
keypoints from your detector then need to be shifted and re-normalized
from the interval \([-1,1]\) to the width and height of your detected
face.

When complete you should be able to produce example images like the one
below

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/obamas4.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         
         
         \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
         \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
         
         \PY{n}{image\PYZus{}copy} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{image}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} plot our image}
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{9}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{image copy}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image\PYZus{}copy}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}13}]:} <matplotlib.image.AxesImage at 0x123fdd610>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_67_1.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}57}]:} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} TODO: Use the face detection code we saw in Section 1 with your trained conv\PYZhy{}net }
         \PY{c+c1}{\PYZsh{}\PYZsh{} TODO : Paint the predicted keypoints on the test image}
         
         \PY{n}{face\PYZus{}cascade}\PY{o}{=}\PY{n}{cv2}\PY{o}{.}\PY{n}{CascadeClassifier}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{detector\PYZus{}architectures/haarcascade\PYZus{}frontalface\PYZus{}default.xml}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)} 
         \PY{n}{img} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/obamas4.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{gray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{img}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2GRAY}\PY{p}{)}
         \PY{n}{faces} \PY{o}{=} \PY{n}{face\PYZus{}cascade}\PY{o}{.}\PY{n}{detectMultiScale}\PY{p}{(}\PY{n}{gray}\PY{p}{,} \PY{l+m+mf}{1.3}\PY{p}{,} \PY{l+m+mi}{6}\PY{p}{)}
         
         \PY{k}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Number of faces detected:}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{len}\PY{p}{(}\PY{n}{faces}\PY{p}{)}\PY{p}{)}
         
         \PY{n}{image\PYZus{}with\PYZus{}detections} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{copy}\PY{p}{(}\PY{n}{img}\PY{p}{)}
         
         \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize}\PY{o}{=}\PY{p}{(}\PY{l+m+mi}{40}\PY{p}{,} \PY{l+m+mi}{40}\PY{p}{)}\PY{p}{)}
         \PY{n}{ax} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{121}\PY{p}{,} \PY{n}{xticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{,} \PY{n}{yticks}\PY{o}{=}\PY{p}{[}\PY{p}{]}\PY{p}{)}  
         
         
             \PY{c+c1}{\PYZsh{} Get the bounding box for each detected face}
         \PY{k}{for} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{w}\PY{p}{,}\PY{n}{h}\PY{p}{)} \PY{o+ow}{in} \PY{n}{faces}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} Add a red bounding box to the detections image}
             \PY{n}{cv2}\PY{o}{.}\PY{n}{rectangle}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{,}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{)}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{255}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
             \PY{n}{cropGBR} \PY{o}{=} \PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{[}\PY{n}{y}\PY{p}{:}\PY{n}{y}\PY{o}{+}\PY{n}{h}\PY{p}{,} \PY{n}{x}\PY{p}{:}\PY{n}{x}\PY{o}{+}\PY{n}{w}\PY{p}{]} 
             \PY{n}{shape} \PY{o}{=} \PY{n}{cropGBR}\PY{o}{.}\PY{n}{shape}
             \PY{n}{cropGray} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{cropGBR}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2GRAY}\PY{p}{)}
             \PY{n}{resized} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{resize}\PY{p}{(}\PY{n}{cropGray}\PY{p}{,} \PY{p}{(}\PY{l+m+mi}{96}\PY{p}{,} \PY{l+m+mi}{96}\PY{p}{)}\PY{p}{)} \PY{o}{/} \PY{l+m+mi}{255}
             \PY{n}{model} \PY{o}{=} \PY{n}{load\PYZus{}model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.hdf5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
             \PY{n}{keypoints} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{squeeze}\PY{p}{(}\PY{n}{model}\PY{o}{.}\PY{n}{predict}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{expand\PYZus{}dims}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{expand\PYZus{}dims}\PY{p}{(}\PY{n}{resized}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{l+m+mi}{0}\PY{p}{)}\PY{p}{,} \PY{n}{axis}\PY{o}{=}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{)}
             \PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{*} \PY{l+m+mi}{48} \PY{o}{+} \PY{l+m+mi}{48}\PY{p}{)}\PY{o}{*}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{/}\PY{l+m+mi}{96}\PY{p}{)}\PY{o}{+}\PY{n}{x}
             \PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{=} \PY{p}{(}\PY{p}{(}\PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]} \PY{o}{*} \PY{l+m+mi}{48} \PY{o}{+} \PY{l+m+mi}{48}\PY{p}{)}\PY{o}{*}\PY{n}{shape}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{/}\PY{l+m+mi}{96}\PY{p}{)}\PY{o}{+}\PY{n}{y}
             
         
             \PY{n}{ax}\PY{o}{.}\PY{n}{scatter}\PY{p}{(}\PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{keypoints}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{:}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{marker}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{o}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{c}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{c}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{s}\PY{o}{=}\PY{l+m+mi}{10}\PY{p}{)}   
         \PY{n}{ax}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image\PYZus{}with\PYZus{}detections}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
('Number of faces detected:', 2)

    \end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}57}]:} <matplotlib.image.AxesImage at 0x1e35253d0>
\end{Verbatim}
            
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_68_2.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    \subsubsection{(Optional) Further Directions - add a filter using facial
keypoints to your laptop
camera}\label{optional-further-directions---add-a-filter-using-facial-keypoints-to-your-laptop-camera}

Now you can add facial keypoint detection to your laptop camera - as
illustrated in the gif below.

The next Python cell contains the basic laptop video camera function
used in the previous optional video exercises. Combine it with the
functionality you developed for keypoint detection and marking in the
previous exercise and you should be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k+kn}{import} \PY{n+nn}{cv2}
        \PY{k+kn}{import} \PY{n+nn}{time} 
        \PY{k+kn}{from} \PY{n+nn}{keras.models} \PY{k+kn}{import} \PY{n}{load\PYZus{}model}
        \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Create instance of video capturer}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
        
            \PY{c+c1}{\PYZsh{} Try to get the first frame}
            \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n}{rval} \PY{o}{=} \PY{n+nb+bp}{False}
            
            \PY{c+c1}{\PYZsh{} keep video stream open}
            \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} plot image from camera with detections marked}
                \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                
                \PY{c+c1}{\PYZsh{} exit functionality \PYZhy{} press any key to exit laptop video}
                \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} exit by pressing any key}
                    \PY{c+c1}{\PYZsh{} destroy windows}
                    \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                    
                    \PY{c+c1}{\PYZsh{} hack from stack overflow for making sure window closes on osx \PYZhy{}\PYZhy{}\PYZgt{} https://stackoverflow.com/questions/6116564/destroywindow\PYZhy{}does\PYZhy{}not\PYZhy{}close\PYZhy{}window\PYZhy{}on\PYZhy{}mac\PYZhy{}using\PYZhy{}python\PYZhy{}and\PYZhy{}opencv}
                    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                        \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                    \PY{k}{return}
                
                \PY{c+c1}{\PYZsh{} read next frame}
                \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}  
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} Run your keypoint face painter}
        \PY{n}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}
\end{Verbatim}


    \subsubsection{(Optional) Further Directions - add a filter using facial
keypoints}\label{optional-further-directions---add-a-filter-using-facial-keypoints}

Using your freshly minted facial keypoint detector pipeline you can now
do things like add fun filters to a person's face automatically. In this
optional exercise you can play around with adding sunglasses
automatically to each individual's face in an image as shown in a
demonstration image below.

To produce this effect an image of a pair of sunglasses shown in the
Python cell below.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} Load in sunglasses image \PYZhy{} note the usage of the special option}
        \PY{c+c1}{\PYZsh{} cv2.IMREAD\PYZus{}UNCHANGED, this option is used because the sunglasses }
        \PY{c+c1}{\PYZsh{} image has a 4th channel that allows us to control how transparent each pixel in the image is}
        \PY{n}{sunglasses} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{images/sunglasses\PYZus{}4.png}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{IMREAD\PYZus{}UNCHANGED}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Plot the image}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{sunglasses}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{axis}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{off}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{;}
\end{Verbatim}


    This image is placed over each individual's face using the detected eye
points to determine the location of the sunglasses, and eyebrow points
to determine the size that the sunglasses should be for each person (one
could also use the nose point to determine this).

Notice that this image actually has \emph{4 channels}, not just 3.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} Print out the shape of the sunglasses image}
        \PY{k}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The sunglasses image has shape: }\PY{l+s+s1}{\PYZsq{}} \PY{o}{+} \PY{n+nb}{str}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{shape}\PY{p}{(}\PY{n}{sunglasses}\PY{p}{)}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    It has the usual red, blue, and green channels any color image has, with
the 4th channel representing the transparency level of each pixel in the
image. Here's how the transparency channel works: the lower the value,
the more transparent the pixel will become. The lower bound (completely
transparent) is zero here, so any pixels set to 0 will not be seen.

This is how we can place this image of sunglasses on someone's face and
still see the area around of their face where the sunglasses lie -
because these pixels in the sunglasses image have been made completely
transparent.

Lets check out the alpha channel of our sunglasses image in the next
Python cell. Note because many of the pixels near the boundary are
transparent we'll need to explicitly print out non-zero values if we
want to see them.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} Print out the sunglasses transparency (alpha) channel}
        \PY{n}{alpha\PYZus{}channel} \PY{o}{=} \PY{n}{sunglasses}\PY{p}{[}\PY{p}{:}\PY{p}{,}\PY{p}{:}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
        \PY{k}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{the alpha channel here looks like}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{print} \PY{p}{(}\PY{n}{alpha\PYZus{}channel}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Just to double check that there are indeed non\PYZhy{}zero values}
        \PY{c+c1}{\PYZsh{} Let\PYZsq{}s find and print out every value greater than zero}
        \PY{n}{values} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{where}\PY{p}{(}\PY{n}{alpha\PYZus{}channel} \PY{o}{!=} \PY{l+m+mi}{0}\PY{p}{)}
        \PY{k}{print} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s1}{ the non\PYZhy{}zero values of the alpha channel look like}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{k}{print} \PY{p}{(}\PY{n}{values}\PY{p}{)}
\end{Verbatim}


    This means that when we place this sunglasses image on top of another
image, we can use the transparency channel as a filter to tell us which
pixels to overlay on a new image (only the non-transparent ones with
values greater than zero).

One last thing: it's helpful to understand which keypoint belongs to the
eyes, mouth, etc. So, in the image below, we also display the index of
each facial keypoint directly on the image so that you can tell which
keypoints are for the eyes, eyebrows, etc.

With this information, you're well on your way to completing this
filtering task! See if you can place the sunglasses automatically on the
individuals in the image loaded in / shown in the next Python cell.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} Load in color image for face detection}
        \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{imread}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{images/obamas4.jpg}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Convert the image to RGB colorspace}
        \PY{n}{image} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{cvtColor}\PY{p}{(}\PY{n}{image}\PY{p}{,} \PY{n}{cv2}\PY{o}{.}\PY{n}{COLOR\PYZus{}BGR2RGB}\PY{p}{)}
        
        
        \PY{c+c1}{\PYZsh{} Plot the image}
        \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize} \PY{o}{=} \PY{p}{(}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{)}\PY{p}{)}
        \PY{n}{ax1} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{111}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}xticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}yticks}\PY{p}{(}\PY{p}{[}\PY{p}{]}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{set\PYZus{}title}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Original Image}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{ax1}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{n}{image}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{}\PYZsh{} (Optional) TODO: Use the face detection code we saw in Section 1 with your trained conv\PYZhy{}net to put}
        \PY{c+c1}{\PYZsh{}\PYZsh{} sunglasses on the individuals in our test image}
\end{Verbatim}


    \subsubsection{(Optional) Further Directions - add a filter using facial
keypoints to your laptop
camera}\label{optional-further-directions---add-a-filter-using-facial-keypoints-to-your-laptop-camera}

Now you can add the sunglasses filter to your laptop camera - as
illustrated in the gif below.

The next Python cell contains the basic laptop video camera function
used in the previous optional video exercises. Combine it with the
functionality you developed for adding sunglasses to someone's face in
the previous optional exercise and you should be good to go!

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{k+kn}{import} \PY{n+nn}{cv2}
        \PY{k+kn}{import} \PY{n+nn}{time} 
        \PY{k+kn}{from} \PY{n+nn}{keras.models} \PY{k+kn}{import} \PY{n}{load\PYZus{}model}
        \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k+kn}{as} \PY{n+nn}{np}
        
        \PY{k}{def} \PY{n+nf}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}\PY{p}{:}
            \PY{c+c1}{\PYZsh{} Create instance of video capturer}
            \PY{n}{cv2}\PY{o}{.}\PY{n}{namedWindow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
            \PY{n}{vc} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{VideoCapture}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
        
            \PY{c+c1}{\PYZsh{} try to get the first frame}
            \PY{k}{if} \PY{n}{vc}\PY{o}{.}\PY{n}{isOpened}\PY{p}{(}\PY{p}{)}\PY{p}{:} 
                \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}
            \PY{k}{else}\PY{p}{:}
                \PY{n}{rval} \PY{o}{=} \PY{n+nb+bp}{False}
            
            \PY{c+c1}{\PYZsh{} Keep video stream open}
            \PY{k}{while} \PY{n}{rval}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} Plot image from camera with detections marked}
                \PY{n}{cv2}\PY{o}{.}\PY{n}{imshow}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{face detection activated}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{frame}\PY{p}{)}
                
                \PY{c+c1}{\PYZsh{} Exit functionality \PYZhy{} press any key to exit laptop video}
                \PY{n}{key} \PY{o}{=} \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{20}\PY{p}{)}
                \PY{k}{if} \PY{n}{key} \PY{o}{\PYZgt{}} \PY{l+m+mi}{0}\PY{p}{:} \PY{c+c1}{\PYZsh{} exit by pressing any key}
                    \PY{c+c1}{\PYZsh{} Destroy windows }
                    \PY{n}{cv2}\PY{o}{.}\PY{n}{destroyAllWindows}\PY{p}{(}\PY{p}{)}
                    
                    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range} \PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}\PY{p}{:}
                        \PY{n}{cv2}\PY{o}{.}\PY{n}{waitKey}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
                    \PY{k}{return}
                
                \PY{c+c1}{\PYZsh{} Read next frame}
                \PY{n}{time}\PY{o}{.}\PY{n}{sleep}\PY{p}{(}\PY{l+m+mf}{0.05}\PY{p}{)}             \PY{c+c1}{\PYZsh{} control framerate for computation \PYZhy{} default 20 frames per sec}
                \PY{n}{rval}\PY{p}{,} \PY{n}{frame} \PY{o}{=} \PY{n}{vc}\PY{o}{.}\PY{n}{read}\PY{p}{(}\PY{p}{)}    
                
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor} }]:} \PY{c+c1}{\PYZsh{} Load facial landmark detector model}
        \PY{n}{model} \PY{o}{=} \PY{n}{load\PYZus{}model}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{my\PYZus{}model.h5}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        
        \PY{c+c1}{\PYZsh{} Run sunglasses painter}
        \PY{n}{laptop\PYZus{}camera\PYZus{}go}\PY{p}{(}\PY{p}{)}
\end{Verbatim}



    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
